1.多线程
    1.1 什么是进程?什么是线程?
        进程是一个应用程序.
        线程是一个进程中的执行场景/执行单元.
        一个进程可以可以启动多个线程.

    1.2 对于Java程序来说,当在DOS窗口中输入:
        java HelloWorld 回车之后.
        会先启动JVM,而JVM就是一个进程.
        JVM再启动一个主线程调用main方法.
        同时再启动一个垃圾回收线程负责看护,回收垃圾.
        最起码,现在的java程序中至少有两个线程并发:一个是垃圾回收线程,一个是执行main方法的主线程.

    1.3 进程和线程之间的关系
        举例:
            阿里巴巴:进程
                马云:阿里巴巴的一个线程
                童文红:阿里巴巴的一个线程
            京东:进程
                强东:京东的一个线程
                妹妹:京东的一个线程

        进程可以看做是现实生活当中的公司
        线程可以看做是公司当中的某个员工

        注意:
            进程A和进程B的内存独立不共享.(阿里巴巴和京东资源不会共享)
                        举例:魔兽游戏是一个进程
                             酷狗音乐是一个进程
                             这两个进程是独立的,不共享资源.
            线程A和线程B呢?
                在java语言中:
                    线程A和线程B,堆内存和方法区内存共享.
                    但是栈内存独立,一个内存一个栈.

                假设启动10个线程,会有10个栈空间,每个栈和每个栈之间,
                互不干扰,各自执行各自的,这就是多线程并发.

                        举例:火车站,可以看做是个进程.
                            火车站中的每一个售票窗口可以看做是一个线程.
                            我在窗口A购票,你可以在窗口B购票,你不需要等我买完,我也不需要等你买完.
                            所以多线程并发可以诶高效率

            java中之所以有多线程机制,目的就是为了提高程序的处理效率.


        1.4 思考一个问题:
            使用了多线程机制之后,main方法结束,是不是有可能程序也不会结束.
            main方法结束只是主线程结束了,主栈空了,其他的栈(线程)可能还在
            压栈弹栈.

        1.5 分析一个问题:对于单核的CPU来说,真的可以真正的做到多线程并发吗?
        对于多核来说,真正的多线程并发是没有问题的.
            什么是真正的多线程并发?
                t1线程执行t1的.
                t2线程执行t2的.
                t1不会影响t2,t2也不会影响t1. 这叫做真正的多线程并发.

            单核的CPU表示只有一个大脑:
                不能做到真正的多线程并发,但是可以做到给人一种"多线程并发"的感觉;
                对于单核的CPU来说,在某一个时间点上实际上只能处理一件事情,但是由
                CPU的处理速度极快,多个线程之间频繁切换执行,给人的感觉是多个事情
                同时在做.
                    线程A:播放音乐
                    线程B:玩游戏
                    线程A和线程B在频繁切换执行,人会感觉边玩游戏边听音乐

                例子:就好比人的眼睛只能接受28帧一样,超过了28帧,人眼就会认为是连续的画面.

2.java语言中,实现线程有两种方式(JDK8新增一种实现Callable接口).

    java支持多线程机制,并且java已经将多线程实现了,我们只需要继承就行

    第一种方式:编写一个类,直接继承java.lang.Thread, 重写run()方法.
        public class Thread.MyThread extends Thread{
            public void run(){}
        }
        Thread.MyThread t = new Thread.MyThread();
        t.start();

    第二种方式:编写一个类,实现java.lang.Runnable接口,实现run()方法;
        public class Thread.MyRunnable implements Runnable{
            public void run(){}
        }
        Thread t = new Thread(new Thread.MyRunnable);
        t.start();

    注意:第二种方式实现接口比较常用,因为一个类可以实现多个接口,但只能继承一个父类.更灵活

3.关于线程调度
    3.1 常见的线程调度模型有哪些?
       抢占式调度模型:
           哪个线程的优先级比较高,抢到的CPU时间片的概率就高一些.
           java采用的就是抢占式调度模型.

       均分批调度模型:
           平均分配CPU时间片,每个线程占有的CPU时间片时间长度一样.
           平均分配,一切平等.

    3.2 java中提供了哪些方法是和线程调度有关系的呢
       实例方法:
             void setPriority(int newPriority) 设置线程的优先级
             int getPriority() 获取线程优先级
             最低优先级1,默认优先级是5,最高优先级是10;
             注意:优先级比较高的获取CPU时间片可能多一些,但也不完全是.

       静态方法:
             static void yield()
             暂停当前正在执行的线程对象,并执行其他线程
             此方法不属于阻塞.让当前的线程让位.让给其他线程使用
             yield()方法的执行会让当前线程从"运行状态"回到"就绪状态"
             注意:在回到就绪状态之后,有可能还会再次抢到

       实例方法:
             void join()
             合并线程
             class Thread.MyThread extends Thread{
                public void run(){
                    Thread.MyThread2 t= new Thread.MyThread2();
                    t.join(); //当前线程进入阻塞,t线程执行,直到t线程结束.当前的线程才可以正常执行(开始抢CPU片)
                }
             }
             class Thread.MyThread2 extends Thread{
             }

4.关于多线程并发环境下,数据的安全问题.
    4.1 为什么这个是重点?
       以后在开发中,我们的项目都是运行在服务器当中的,
       而服务器已经将线程的定义,线程对象的创建,线程
       的启动等,都已经实现完了.这些代码我们都不需要
       编写.

       最重要的是:你要知道,你编写的程序需要放到一个
       多线程的环境下运行,你更需要关注的是这些数据
       在多线程并发的环境下是否安全的.(重点*****)

    4.2 什么时候数据在多线程并发的环境下会存在安全问题的呢?
       三个条件:
            条件1:多线程并发
            条件2:操作共享数据
            条件3:共享数据有修改的行为.
       满足以上三个条件,就会存在线程安全问题

    4.3 怎么解决线程安全问题呢?
       当多线程并发的情况下,有共享数据,并且这个数据还会被修改,此时就会存在
       线程安全问题,怎么解决这个问题?
           线程排队执行.(不能并发)
           用排队执行解决线程安全问题.
           这种机制被称为:线程同步机制.
           专业术语叫做:线程同步,实际上就是线程不能并发了,线程必须排队执行.

       提问:怎么解决线程安全问题呀?
           使用"线程同步机制".
       线程同步就是线程排队了,线程排队了就会牺牲一部分效率,没办法,数据安全第一位
       只有数据安全了,我们才可以谈效率.

    4.4 说到线程同步这块,涉及到这两个专业术语:
       异步编程模型:
            线程t1和线程t2各自执行各自的.t1不管t2,t2不管t1,
            谁也不需要等谁,这种编程模型叫做:异步编程模型.
            其实就是:多线程并发(效率较高)

       同步编程模型:
            线程t1和线程t2,在线程t1执行的时候,必须等待t2线程执行结束
            或者说,在t2线程执行的时候,必须等待t1线程执行结束,两个线
            程之间发生了等待关系,这就是同步编程模型.
            其实就是:线程排队执行(效率较低)

        总结:异步就是并发,同步就是排队.

5. Java中有三大变量
    实例变量_全局变量_成员变量Demo:在堆中.
    静态变量:在方法区中.
    局部变量:在栈中

    以上三大变量中:
    局部变量永远都不会存在线程安全问题.因为局部变量不共享.(一个线程一个栈)
    局部变量在栈中.所以局部变量永远都不会共享.

    实例变量在堆中,堆中只有1个.
    静态变量在方法区中,方法区只有1个.
    堆和方法区都是多线程共享的,所以可能存在线程安全问题.

6.总结
    synchronized有三种写法:
        第一种:同步的代码块
            灵活
            synchronized(线程共享对象){
                同步代码块
            }
        第二种:在实例方法上使用synchronized
            表示共享对象一定是this
            并且同步代码块是整个方法体.

        第三种:在静态方法上使用synchronized
            表示找类锁.
            类锁永远只有1把.
            就算创建了100个对象,那类锁也只有1把.

        对象锁:1个对象1把锁,100个对象100把锁.
        类锁:100个对象,也可能只是1把类锁.

7.聊一聊,我们以后开发中应该怎么解决线程安全问题?

    并不是直接使用synchronized,因为会降低程序的执行效率,用户体验不好.
    系统的用户吞吐量降低.

    第一种方案:尽量使用局部变量,代替实例变量和静态变量.

    第二种方案:如果必须是实例变量,那么可以考虑创建多个对象,这样实例变量的内存
    就不共享了.(1个线程对应1个对象,100个线程对应100个对象,对象不共享,就没有
    数据安全问题了)

    第三种方案:第一种和第二种方案都不行,就只能选择synchronized.使用线程同步机制.

8.线程这块还有那些内容呢?列举一下
    8.1 守护线程
       java语言中,线程分为两大类:
            一类是:用户线程
            一类是:守护线程(后台线程)
            其中具有代表性的就是:垃圾回收线程(守护线程)

       守护线程的特点:
            一般守护线程是一个死循环,所有的用户线程只要结束,守护线程自动结束.

       注意:主线程main方法是一个用户线程.

       守护线程用在什么地方呢?
            每天0点的时候,系统数据自动备份.
            这个需要使用到定时器,并且可以将定时器设置成守护线程.
            一直在那看着,每到0点的时候就备份一次.所有的用户线程
            如果结束了,守护线程自动退出,就没有必要进行数据备份了

    8.2 定时器
       定时器的作用:
           间隔特定的时间,执行特定的程序.

           例如:每周要进行银行账户的总账操作,每天要进行数据的备份操作.

           在实际开发中,每隔多久执行一段特定的程序,这种需求是很常见的,
           那么在java中其实可以采用多种方式实现

               可以使用sleep方法,睡眠,设置睡眠时间,每到这个时间点醒来,执行
               任务.这种方式是最原始的定时器

               在java的类库中已经写好了一个定时器,java.util.Timer,可以直接拿来
               用.不过,这种方式在目前的开发中也很少用,因为现在很多高级框架都是
               支持定时任务的.

               在实际开发中,目前使用较多的是Spring框架中提供的SpringTask框架,
               在这个框架只要进行简单的配置,就可以完成定时器的任务.


    8.3 实现线程的第三种方式:实现Callable接口.(JDK8新特性)
        这种方式实现的线程可以获取线程的返回值。
        之前讲解的那两种方式是无法获取线程返回值的，因为run方法返回void。

        思考：
            系统委派一个线程去执行一个任务，该线程执行完任务之后，可能
            会有一个执行结果，我们怎么能拿到这个执行结果呢？
                使用第三种方式：实现Callable接口方式

    8.4 关于Object类中的wait和notify方法.(生产者和消费者模式)
        第一：wait和notify方法不属于线程特有方法，是java中任何一个对象都有的方法
        因为这两个方法都是Object自带的
            wait方法和notify方法不是通过线程对象调用的，
            不是这样的：t.wait(),t.notify(). 不对。

        第二：wait()方法作用
            Object o = new Object()
            o.wait()
            表示：
                让正在o对象上活动的线程进入等待状态，无期限等待，
                直到被唤醒为止。
                o.wait()方法的调用，会让"当前线程(正在o对象上
                活动的线程)"进入等待状态。

        第二：notify()方法作用
            Object o = new Object()
            o.notify()
            表示：
                唤醒正在o对象上等待的线程

            还有一个notifyAll()方法
                唤醒o对象上等待的所有线程
